# "Event Sourcing"
![Step 12 - Event Sourcing](../img/step12.webp)

Nous avons des `ersatzs` d'√©v√©nements au sein de notre `PartieDeChasse`.

Ceux-ci sont extr√™mement limit√©s :
- ils ne portent aucune s√©mantique m√©tier
- pas structur√©s : ce sont de simples `string`

```csharp
private readonly List<Event> _events;
public sealed record Event(DateTime Date, string Message)
{
    public override string ToString() => string.Format("{0:HH:mm} - {1}", Date, Message);
}

if (TousBrocouilles(classement))
{
    result = "Brocouille";
    EmitEvent("La partie de chasse est termin√©e, vainqueur : Brocouille", timeProvider);
}
else
{
    result = Join(", ", classement[0].Select(c => c.Nom));
    EmitEvent(
        $"La partie de chasse est termin√©e, vainqueur : {Join(", ", classement[0].Select(c => $"{c.Nom} - {c.NbGalinettes} galinettes"))}",
        timeProvider);
}
```

On va revoir cette gestion des √©v√©nements et allons en profiter pour `Event-sourcer` notre `Aggregate`. Cela signifie que nous n'allons plus stocker l'√©tat de notre `Aggregate` mais tous ses √©v√©nements.

Pour cela, on va :
- Prendre du temps pour d√©couvrir ce qu'est l'[`Event Sourcing`](https://martinfowler.com/eaaDev/EventSourcing.html)
- Quelques classes ont d√©j√† √©t√© impl√©ment√© afin de faciliter l'utilisation d'1 `Event Store` in memory
    - Faire 1 `checkout` du commit `6efde7c3e470e7c84c50da2715c255bd9acd3d6c`

```shell
git checkout 5b3129f2bc384ccc707b3f6bb730ff2ef9999167
```

- Cette version est tr√®s minimaliste et ne r√©solve pas des probl√©matiques telles que la concurrence
- Prendre du temps pour comprendre le code du `Domain.Core`
    - Ce code est fortement inspir√© du travail fait sur [`NEventStore`](https://github.com/NEventStore/NEventStore)
    - Pour comprendre comment utiliser ce code, on peut se focaliser sur les tests qui nous en donnent une bonne id√©e

```csharp
[Fact]
public class AggregateShould
{
    private readonly Guid _id;
    private readonly Movie _movie;

    public AggregateShould()
    {
        _id = Guid.NewGuid();
        _movie = Oppenheimer.Movie(_id);
    }

    [Fact]
    public void have_raised_creation_event()
    {
        _movie.HasRaisedEvent(new MovieCreated(_id, Data.Now, Oppenheimer.Title, Oppenheimer.ReleaseDate))
            .Should()
            .BeTrue();
        _movie.Version.Should().Be(1);
        _movie.Id.Should().Be(_id);
    }

    [Fact]
    public void have_raised_casting_changed_event()
    {
        var newCasting = new List<string> {"Cillian Murphy", "Florence Pugh"}.ToSeq();

        _movie.ChangeCast(newCasting);

        _movie.HasRaisedEvent(new CastingHasChanged(_id, Data.Now, newCasting))
            .Should()
            .BeTrue();

        _movie.Version.Should().Be(2);
    }

    [Fact]
    public void throw_handler_not_found_when_apply_method_not_defined()
    {
        var act = () => _movie.NotWellImplementedBehavior();
        act.Should()
            .Throw<HandlerForDomainEventNotFoundException>()
            .WithMessage(
                "Aggregate of type 'Movie' raised an event of type 'NotWellImplementedDomainBehaviorRaised' but no handler could be found to handle the event.");
    }
    ...
}

public class Movie : Aggregate
{
    // public only for testing purpose
    public string? _title;
    public DateTime? _releaseDate;
    public Seq<string> _casting = Seq<string>.Empty;
    private Movie(Guid id, Func<DateTime> timeProvider) : base(timeProvider, true) => Id = id;

    public Movie(Guid id, Func<DateTime> timeProvider, string title, DateTime releaseDate) : this(id, timeProvider)
        => RaiseEvent(new MovieCreated(id, Time(), title, releaseDate));

    private void Apply(MovieCreated @event)
    {
        _title = @event.Title;
        _releaseDate = @event.ReleaseDate;
    }

    public void ChangeCast(Seq<string> casting) => RaiseEvent(new CastingHasChanged(Id, Time(), casting));

    private void Apply(CastingHasChanged @event) => _casting = @event.Casting;

    public void NotWellImplementedBehavior() => RaiseEvent(new NotWellImplementedDomainBehaviorRaised(Id, Time()));
}

public record MovieCreated(Guid Id, DateTime Date, string Title, DateTime ReleaseDate) : Event(Id, 1, Date);

public record CastingHasChanged(Guid Id, DateTime Date, Seq<string> Casting) : Event(Id, 1, Date);

public record NotWellImplementedDomainBehaviorRaised(Guid Id, DateTime Date) : Event(Id, 1, Date);
```

- Identifier quels sont les √©l√©ments fondamentaux √† mettre en place pour avoir 1 `Aggregate` "Event-Sourc√©"

## Changer l'impl√©mentation de `Prendre LAp√©ro`
Faire en sorte que le flux ressemble √† cela :

![Events](steps/img/12.event-sourcing/events.webp)

- Pour le moment au sein de notre `Domain` son impl√©mentation ressemble √† √ßa :

```csharp
public Either<Error, PartieDeChasse> PrendreLap√©ro(Func<DateTime> timeProvider)
{
    if (DuringAp√©ro())
    {
        return AnError("On est d√©j√† en plein ap√©ro");
    }

    if (D√©j√†Termin√©e())
    {
        return AnError("La partie de chasse est d√©j√† termin√©e");
    }

    Status = Ap√©ro;
    EmitEvent("Petit ap√©ro", timeProvider);

    return this;
}
```

- Soyons plus explicite en retournant `Either<Error, Unit>`
    - On ne stockera plus l'√©tat mais que les `Events` donc plus besoin de retourner le nouvel √©tat de l'objet

√Ä toi de jouer maintenant üòâ

## Reflect
- Qu'est-ce que cela a simplifi√© ?
- Au contraire complexifi√© ?
- Qu'est ce que tu en penses ?
  
![Event Sourcing](steps/img/12.event-sourcing/event-sourcing.webp)

## Solution
Guide √©tape par √©tape disponible [ici](steps/12.event-sourcing.md).