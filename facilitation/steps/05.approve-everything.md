# "Approve Everything"
Il y a quelques tests pour lesquels nous avons Ã©normÃ©ment de lignes d'assertions. 
Nous allons les retravailler afin de les transformer en `Approval Tests`.

- Prendre du temps pour comprendre ce qui se cache derriÃ¨re cette notion d'[Approval Testing](https://github.com/ythirion/approval-testing-kata#2-approval-testing)
- Identifier des tests sur lesquels on pourrait utiliser cette technique
- Refactorer un test existant en utilisant la librairie [Verify](https://github.com/VerifyTests/Verify)
  
![Step 5 - Approve Everything](../../img/step5.webp)

## Identification des tests
On pourrait utiliser cette technique pour les tests suivants :
- `DemarrerUnePartieDeChasse.AvecPlusieursChasseurs`
  - Limitera les asserts Ã  une seule ligne
  - Moins de maintenance et assertions plus lisibles
- `ConsulterStatus` : `QuandLaPartieVientDeDÃ©marrer` / `QuandLaPartieEstTerminÃ©e`
- `ScenarioTests.DÃ©roulerUnePartie`
  - On valide le contenu d'un `string`
  - Cela Ã©vitera de stocker ce string dans le code (sera stockÃ© sous forme de ressource)

## Refactorer `ScenarioTests.DÃ©roulerUnePartie`
- On commence par ajouter la dÃ©pendance sur notre librairie d'Approval Testing

```shell
dotnet add package Verify.xUnit
```

- On peut ensuite extraire le contenu de l'assertion dans un fichier "Approved" ici "verified"
  - On crÃ©e un fichier appelÃ© : `ScenarioTests.DÃ©roulerUnePartie.verified.txt` (`[Nom de la classe de tests].[Nom du test].verified.txt`)
  - C'est sur base de ce fichier que l'assertion se fera via `Verify`
![Approved Content](img/05.approve-everything/approved-content.webp)

- On transforme le test en `Approval Test` en
  - Ajoutant l'annotation `UsesVerify` sur la classe de test
  - Changeant la mÃ©thode de test pour que celle-ci renvoie une `Task`

```csharp
[UsesVerify]
public class ScenarioTests
{
    [Fact]
    public Task DÃ©roulerUnePartie()
    {
        var time = new DateTime(2024, 4, 25, 9, 0, 0);
        var repository = new PartieDeChasseRepositoryForTests();
        var service = new PartieDeChasseService(repository, () => time);
        var chasseurs = new List<(string, int)>
        {
            ("DÃ©dÃ©", 20),
            ("Bernard", 8),
            ("Robert", 12)
        };
        var terrainDeChasse = ("Pitibon sur Sauldre", 4);
        var id = service.Demarrer(
            terrainDeChasse,
            chasseurs
        );

        time = time.Add(TimeSpan.FromMinutes(10));
        service.Tirer(id, "DÃ©dÃ©");

        time = time.Add(TimeSpan.FromMinutes(30));
        service.TirerSurUneGalinette(id, "Robert");

        time = time.Add(TimeSpan.FromMinutes(20));
        service.PrendreLapÃ©ro(id);

        time = time.Add(TimeSpan.FromHours(1));
        service.ReprendreLaPartie(id);

        time = time.Add(TimeSpan.FromMinutes(2));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromMinutes(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromMinutes(1));
        service.TirerSurUneGalinette(id, "DÃ©dÃ©");

        time = time.Add(TimeSpan.FromMinutes(26));
        service.TirerSurUneGalinette(id, "Robert");

        time = time.Add(TimeSpan.FromMinutes(10));
        service.PrendreLapÃ©ro(id);

        time = time.Add(TimeSpan.FromMinutes(170));
        service.ReprendreLaPartie(id);

        time = time.Add(TimeSpan.FromMinutes(11));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));
        service.Tirer(id, "Bernard");

        time = time.Add(TimeSpan.FromSeconds(1));

        try
        {
            service.Tirer(id, "Bernard");
        }
        catch (TasPlusDeBallesMonVieuxChasseALaMain)
        {
        }

        time = time.Add(TimeSpan.FromMinutes(19));
        service.TirerSurUneGalinette(id, "Robert");

        time = time.Add(TimeSpan.FromMinutes(30));
        service.TerminerLaPartie(id);

        // retourne le rÃ©sultat de la mÃ©thode `Verify`
        return Verify(service.ConsulterStatus(id));
    }
}
```

Le test passe du premier coup ğŸ‘Œ

On va faire en sorte de le faire passer au rouge : `ne jamais croire un test qu'on a pas vu Ã©chouer`...

Pour cela le plus simple est de changer le fichier `verified`.

Notre `Approval Test` Ã©choue, notre outil de comparaison de fichier va s'ouvrir :
![File compare](img/05.approve-everything/compare-files.webp)

DÃ¨s lors nous avons une arborescence de fichiers ressemblant Ã  cela :
![Files](img/05.approve-everything/files.webp)

Un Ã©lÃ©ment important quand on utilise une librairie de ce genre, ajouter les fichiers `received` dans le fichier `.gitignore` :

```text
# Verify
*.received.txt
```

FÃ©licitations, notre premier test passe et on peut se fier Ã  lui.

En revanche, le test n'est pas trÃ¨s lisible / maintenable :
- Beaucoup de duplication
- `try / catch` vide
- MÃ©thode de plus de `80 loc`

On va y appliquer la fameuse [rÃ¨gle du boyscout](https://deviq.com/principles/boy-scout-rule).
![Boy scout rule](img/05.approve-everything/boy-scout-rule.webp)

### Boy Scout Rule
- On commence par extraire des champs Ã  partir du test via notre `IDE`
![Introduce Field](img/05.approve-everything/introduce-field.webp)

- Puis on configure l'extraction
![Introduce Field details](img/05.approve-everything/introduce-field-refactoring.webp)

- Le rÃ©sultat est :
```csharp
public class ScenarioTests
{
    private DateTime _time = new(2024, 4, 25, 9, 0, 0);
    private readonly PartieDeChasseService _service;

    public ScenarioTests()
    {
        _service = new PartieDeChasseService(
            new PartieDeChasseRepositoryForTests(),
            () => _time
        );
    }
    ....
}
```

- On va utiliser le `CommandBuilder` Ã©galement
  - Afin de supprimer les `string` hardcodÃ©s

```csharp
var command = DÃ©marrerUnePartieDeChasse()
    .Avec(("DÃ©dÃ©", 20), ("Bernard", 8), ("Robert", 12))
    .SurUnTerrainRicheEnGalinettes(4);

var id = _service.Demarrer(
    command.Terrain,
    command.Chasseurs
);
```

- On va ensuite supprimer la duplication en faisant une extraction des constantes : `Bernard`, `Robert`, `DÃ©dÃ©`, `ChasseurInconnu`
  - Pour pouvoir les utiliser dans cette classe de test Ã©galement
  - On les place dans un fichier `Data`

![Move to type](img/05.approve-everything/move-type.webp)

- Notre test ressemble dÃ©sormais Ã  cela

```csharp
[Fact]
public Task DÃ©roulerUnePartie()
{
    var command = DÃ©marrerUnePartieDeChasse()
        .Avec((Data.DÃ©dÃ©, 20), (Data.Bernard, 8), (Data.Robert, 12))
        .SurUnTerrainRicheEnGalinettes(4);

    var id = _service.Demarrer(
        command.Terrain,
        command.Chasseurs
    );

    _time = _time.Add(TimeSpan.FromMinutes(10));
    _service.Tirer(id, Data.DÃ©dÃ©);

    _time = _time.Add(TimeSpan.FromMinutes(30));
    _service.TirerSurUneGalinette(id, Data.Robert);
    
    ....
}
```

- On va extraire une mÃ©thode Ã  partir de cela en identifiant les similitudes et diffÃ©rences
```csharp
// Ajoute du temps Ã  _time
_time = _time.Add(TimeSpan.FromMinutes(30));
// Appelle d'une mÃ©thode sur le service
_service.TirerSurUneGalinette(id, Data.Robert);

// Ajoute du temps Ã  _time
_time = _time.Add(TimeSpan.FromMinutes(20));
// Appelle d'une mÃ©thode sur le service
_service.PrendreLapÃ©ro(id);
```

- On prÃ©pare notre `extraction` en dÃ©composant le code ci-dessus en :
```csharp
// Extract variable
var timeToAdd = TimeSpan.FromMinutes(10);
// Refactor l'appelle en Action
var act = () => _service.Tirer(id, Data.DÃ©dÃ©);

_time = _time.Add(timeToAdd);
act();
```

- Extraction de la mÃ©thode
![Extract method](img/05.approve-everything/extract-method.webp)

- Puis on configure la mÃ©thode
![Configure Extract Method](img/05.approve-everything/configure-extract.webp)

- On l'utilise partout en s'assurant que notre test reste vert
  - En rendant Ã©galement `safe` l'appelle Ã  la mÃ©thode `act`

```csharp
[UsesVerify]
public class ScenarioTests
{
    private DateTime _time = new(2024, 4, 25, 9, 0, 0);
    private readonly PartieDeChasseService _service;

    public ScenarioTests()
    {
        _service = new PartieDeChasseService(
            new PartieDeChasseRepositoryForTests(),
            () => _time
        );
    }

    [Fact]
    public Task DÃ©roulerUnePartie()
    {
        var command = DÃ©marrerUnePartieDeChasse()
            .Avec((Data.DÃ©dÃ©, 20), (Data.Bernard, 8), (Data.Robert, 12))
            .SurUnTerrainRicheEnGalinettes(4);

        var id = _service.Demarrer(
            command.Terrain,
            command.Chasseurs
        );

        After(10.Minutes(), () => _service.Tirer(id, Data.DÃ©dÃ©));
        After(30.Minutes(), () => _service.TirerSurUneGalinette(id, Data.Robert));
        After(20.Minutes(), () => _service.PrendreLapÃ©ro(id));
        After(1.Hours(), () => _service.ReprendreLaPartie(id));
        After(2.Minutes(), () => _service.Tirer(id, Data.Bernard));
        After(1.Minutes(), () => _service.Tirer(id, Data.Bernard));
        After(1.Minutes(), () => _service.TirerSurUneGalinette(id, Data.DÃ©dÃ©));
        After(26.Minutes(), () => _service.TirerSurUneGalinette(id, Data.Robert));
        After(10.Minutes(), () => _service.PrendreLapÃ©ro(id));
        After(170.Minutes(), () => _service.ReprendreLaPartie(id));
        After(11.Minutes(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(1.Seconds(), () => _service.Tirer(id, Data.Bernard));
        After(19.Minutes(), () => _service.TirerSurUneGalinette(id, Data.Robert));
        After(30.Minutes(), () => _service.TerminerLaPartie(id));

        return Verify(_service.ConsulterStatus(id));
    }

    private void After(TimeSpan time, Action act)
    {
        _time = _time.Add(time);
        try
        {
            act();
        }
        catch
        {
            // ignored
        }
    }
}
```

## Refactorer `DemarrerUnePartieDeChasse.AvecPlusieursChasseurs`
- On commence par changer le test
  - Ici on va "approuver" la reprÃ©sentation textuelle de la `PartieDeChasse`

```csharp
[Fact]
public Task AvecPlusieursChasseurs()
{
    var command = DÃ©marrerUnePartieDeChasse()
        .Avec((Data.DÃ©dÃ©, 20), (Data.Bernard, 8), (Data.Robert, 12))
        .SurUnTerrainRicheEnGalinettes();

    PartieDeChasseService.Demarrer(
        command.Terrain,
        command.Chasseurs
    );

    return Verify(Repository.SavedPartieDeChasse());
}
```

- Voici le rÃ©sultat
  - Par dÃ©faut, `Verify` va scrubber les donÃ©es non dÃ©terministes (`DateTime` et `Guid` ici)

![Verify scrubbers](img/05.approve-everything/verify-scrubbed-data.webp)

- Concernant la date, on perd 1 assertion faites dans le test avant refactoring
  - On change la configuration pour ce test

```csharp
[Fact]
public Task AvecPlusieursChasseurs()
{
    var command = DÃ©marrerUnePartieDeChasse()
        .Avec((Data.DÃ©dÃ©, 20), (Data.Bernard, 8), (Data.Robert, 12))
        .SurUnTerrainRicheEnGalinettes();

    PartieDeChasseService.Demarrer(
        command.Terrain,
        command.Chasseurs
    );

    return Verify(Repository.SavedPartieDeChasse())
        // On prÃ©cise qu'on ne veut pas "scubber" les DateTime
        .DontScrubDateTimes();
}
```

- On peut maintenant approver le rÃ©sultat du test qui ressemble Ã  cela

![Verify scrubbers](img/05.approve-everything/verify-demarrer.webp)

## Impact du refactoring des tests
### Codescene
AprÃ¨s les refactorings des tests, on peut lancer une analyse `codescene` pour vÃ©rifier leur impact sur l'Ã©tat de notre code base :
![code scene health](img/05.approve-everything/codescene-health.webp)

> Nous sommes passÃ© d'une Code Health de 8,4 Ã  9,8 ğŸ‘Œ

Les hotspots ont changÃ© de taille (rouges car les commits sont trÃ¨s rÃ©cents)
![code scene hotspots](img/05.approve-everything/codescene-hotspots.webp)

Il reste 1 `refactoring target` : `PartieDeChasseService`
![code scene target](img/05.approve-everything/codescene-refactoring-targets.webp)

### SonarCloud
Rapport disponible [ici](https://sonarcloud.io/summary/overall?id=ythirion_refactoring-du-bouchonnois&branch=steps%2F05-approve-everything).

## Reflect
- Que pensez vous de cette technique ?
  - Quels autres cas d'utilisation pouvez-vous identifier ?
- Qu'est-ce que le `scrubbing` ?

![Approve everything](img/05.approve-everything/approved.webp)